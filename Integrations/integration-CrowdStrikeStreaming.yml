category: End Point
commonfields: {id: integration-CrowdStrikeStreaming, version: -1}
configuration:
- defaultvalue: ''
  display: Fetch incidents
  name: isFetch
  options: []
  required: false
  type: 8
- defaultvalue: ''
  display: Incident type
  name: incidentType
  options: []
  required: false
  type: 13
- defaultvalue: https://falconapi.crowdstrike.com
  display: Server URL (e.g. https://example.net)
  name: url
  options: []
  required: true
  type: 0
- defaultvalue: ''
  display: Username
  name: credentials
  options: []
  required: true
  type: 9
- defaultvalue: 'true'
  display: Trust any certificate (unsecure)
  name: insecure
  options: []
  required: false
  type: 8
- defaultvalue: ''
  display: Use system proxy
  name: proxy
  options: []
  required: false
  type: 8
- defaultvalue: 3 days
  display: First fetch timestamp (<number> <time unit>, e.g., 12 hours, 7 days)
  name: fetch_time
  options: []
  required: false
  type: 0
description: The Falcon Streaming API (formerly known as the Falcon Firehose API)
detaileddescription: Use these detailed instructions in order to retrieve the API
  key
display: CrowdStrike Falcon Streaming V2
name: integration-CrowdStrikeStreaming
script:
  commands: []
  dockerimage: ''
  isfetch: true
  runonce: false
  script: |-
    ''' IMPORTS '''

    import json
    import requests
    from distutils.util import strtobool

    # Disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    ''' GLOBALS/PARAMS '''

    USERNAME = demisto.params().get('credentials').get('identifier')
    PASSWORD = demisto.params().get('credentials').get('password')
    TOKEN = demisto.params().get('token')
    # Remove trailing slash to prevent wrong URL path to service
    SERVER = demisto.params()['url'][:-1] if (demisto.params()['url'] and demisto.params()['url'].endswith('/')) else demisto.params()['url']
    # Should we use SSL
    USE_SSL = not demisto.params().get('unsecure', False)
    # How many time before the first fetch to retrieve incidents
    FETCH_TIME = demisto.params().get('fetch_time', '3 days')
    # Headers to be sent in requests
    HEADERS = {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
    }
    # Remove proxy if not set to true in params
    if not demisto.params().get('proxy'):
        del os.environ['HTTP_PROXY']
        del os.environ['HTTPS_PROXY']
        del os.environ['http_proxy']
        del os.environ['https_proxy']

    ''' KEY DICTIONARY '''

    DETECTIONS_BASE_KEY_MAP = {
        'Detections.device.hostname': 'System',
        'Detections.device.cid': 'CustomerIDString',
        'Detections.hostinfo.domain': 'MachineDomain',
    }

    DETECTIONS_BEHAVIORS_KEY_MAP = {
        'filename': 'FileName',
        'scenario': 'ScanDetectName', #  the value doesn't match 100%, but it's close
        'md5': 'MD5String',
        'sha256': 'SHA256String',
        'ioc_type': 'IOCType',
        'ioc_value': 'IOCValue',
        'cmdline': 'CommandLine',
        'user_name': 'UserName'
    }

    #   Pattern: {'Path': 'Path to item', 'NewKey': 'Value of output key', 'Delim': 'Delimiter char', 'Index': Split Array Index}
    DETECTIONS_BEHAVIORS_SPLIT_KEY_MAP = [
        {
            'Path': 'parent_details.parent_process_graph_id',
            'NewKey': 'SensorID',
            'Delim': ':',
            'Index': 1
        },
        {
            'Path': 'parent_details.parent_process_graph_id',
            'NewKey': 'ParentProcessID',
            'Delim': ':',
            'Index': 2
        },
        {
            'Path': 'parent_details.parent_process_graph_id',
            'NewKey': 'ProcessStartTime',
            'Delim': ':',
            'Index': 2
        },
        {
            'Path': 'triggering_process_graph_id',
            'NewKey': 'ProcessID',
            'Delim': ':',
            'Index': 2
        },
    ]

    ''' HELPER FUNCTIONS '''


    def http_request(method, url_suffix, params=None, data=None):
        # A wrapper for requests lib to send our requests and handle requests and responses better
        demisto.info('#### url: {}'.format(SERVER + url_suffix))
        res = requests.request(
            method,
            # 'https://httpbin.org/post',
            SERVER + url_suffix,
            verify=USE_SSL,
            params=params,
            data=data,
            headers=HEADERS,
            auth=(USERNAME, PASSWORD)
        )
        demisto.info('#### AFTER REQUEST')
        demisto.info('#### STATUS CODE: {}'.format(res.status_code))
        # Handle error responses gracefully
        if res.status_code not in {200}:
            return_error('Error in API call to Example Integration [%d] - %s' % (res.status_code, res.reason))
        demisto.info("\n\n{0}\n\n".format(str(res.json())))
        return res.json()


    def behavior_to_incident(behavior, raw_response):
        demisto.info("\n\n #### IN behavior_to_incident")
        raw_labels = get_trasnformed_dict(behavior, DETECTIONS_BEHAVIORS_KEY_MAP)
        raw_labels.update(extract_transformed_dict_with_split(behavior, DETECTIONS_BEHAVIORS_SPLIT_KEY_MAP))
        for path, new_key in DETECTIONS_BASE_KEY_MAP.iteritems():
            raw_labels[new_key] = demisto.get(raw_response, path)
        labels = [{'Type': k, 'Value': v} for k, v in raw_labels.iteritems()]
        demisto.info("\n\n #### labels value: {}".format(json.dumps(labels, indent=4, sort_keys=True)))
        incident = {
            'name': 'Behavior id: ' + str(behavior.get('behavior_id')),
            'occurred': behavior.get('timestamp'),
            'rawJSON': json.dumps(behavior),
            'labels': labels
        }
        # demisto.info("\n\n #### Incident value: {}".format(json.dumps(incident, indent=4, sort_keys=True)))
        return incident


    def get_trasnformed_dict(old_dict, transformation_dict):
        """
           Returns a dictionary with the same values as old_dict, with the correlating key:value in transformation_dict
        """
        new_dict = {}
        for k in old_dict.keys():
            if k in transformation_dict:
                new_dict[transformation_dict[k]] = old_dict[k]
        return new_dict


    def extract_transformed_dict_with_split(old_dict, transformation_dict_arr):
        """
           Extracts new values out of old_dict using a json structure of:
           {'Path': 'Path to item', 'NewKey': 'Value of output key', 'Delim': 'Delimiter char', 'Index': Split Array Index}
        """
        new_dict = {}
        for trans_dict in transformation_dict_arr:
            try:
                val = demisto.get(old_dict, trans_dict['Path'])
                if 'split' in dir(val):
                    i = trans_dict['Index']
                    new_dict[trans_dict['NewKey']] = val.split(trans_dict['Delim'])[i]
            except:
                LOG('Error with: {}'.format(trans_dict))
        return new_dict


    ''' COMMANDS + REQUESTS FUNCTIONS '''


    def test_module():
        """
        Performs basic get request to get item samples
        """
        return http_request('GET', 'detects/queries/detects/v1')


    def get_detections_request(last_behavior_time):
        # The service endpoint to request from
        endpoint_url = '/detects/queries/detects/v1'
        # Dictionary of params for the request
        params = {
            'filter': "first_behavior:>'{0}'".format(last_behavior_time),
            'sort': 'first_behavior.asc'
        }
        # Send a request using our http_request wrapper
        response = http_request('GET', endpoint_url, params)
        # Check if response contains errors
        if response.get('errors'):
            return_error(response.get('errors'))
        return response


    def get_detections_entities_request(detections_ids):
        ids_json = {'ids': detections_ids}
        response = http_request('POST', '/detects/entities/summaries/GET/v1', data=json.dumps(ids_json))
        # Check if response contains errors
        if response.get('errors'):
            return_error(response.get('errors'))
        return response


    def fetch_incidents():
        last_run = demisto.getLastRun()
        # Get the last fetch time, if exists
        last_fetch = last_run.get('first_behavior_time')

        # Handle first time fetch, fetch incidents retroactively
        if last_fetch is None:
            last_fetch, _ = parse_date_range(FETCH_TIME, date_format='%Y-%m-%dT%H:%M:%SZ')
        last_fetch_timestamp = date_to_timestamp(last_fetch, date_format='%Y-%m-%dT%H:%M:%SZ')

        incidents = []
        detections_ids = demisto.get(get_detections_request(last_fetch), 'resources')
        raw_res = get_detections_entities_request(detections_ids)
        demisto.info('\n#### Items: {}\n'.format(raw_res))
        demisto.info('\n#### Resources: {}\n'.format(demisto.get(raw_res, 'resources')))
        for resource in demisto.get(raw_res, "resources"):
            for behavior in demisto.get(resource, 'behaviors'):
                incident = behavior_to_incident(behavior, resource)
                incident_date = incident['occurred']
                incident_date_timestamp = date_to_timestamp(incident_date, date_format='%Y-%m-%dT%H:%M:%SZ')
                # Update last run and add incident if the incident is newer than last fetch
                if incident_date_timestamp > last_fetch_timestamp:
                    last_fetch = incident_date
                incidents.append(incident)

        demisto.setLastRun({'first_behavior_time': last_fetch})
        demisto.incidents(incidents)


    ''' COMMANDS MANAGER / SWITCH PANEL '''

    LOG('Command being called is %s' % (demisto.command()))

    if demisto.command() == 'test-module':
        # This is the call made when pressing the integration test button.
        test_module()
        demisto.results('ok')
    elif demisto.command() == 'fetch-incidents':
        # Set and define the fetch incidents command to run after activated via integration settings.
        fetch_incidents()
  type: python
