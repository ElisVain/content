category: End Point
commonfields:
  id: integration-CrowdStrikeStreaming
  version: -1
configuration:
- display: Fetch incidents
  name: isFetch
  required: false
  type: 8
- display: Incident type
  name: incidentType
  required: false
  type: 13
- defaultvalue: https://falconapi.crowdstrike.com
  display: Server URL (e.g. https://example.net)
  name: url
  required: true
  type: 0
- display: Username
  name: credentials
  required: true
  type: 9
- defaultvalue: 'true'
  display: Trust any certificate (unsecure)
  name: insecure
  required: false
  type: 8
- display: Use system proxy
  name: proxy
  required: false
  type: 8
- defaultvalue: 3 days
  display: First fetch timestamp (<number> <time unit>, e.g., 12 hours, 7 days)
  name: fetch_time
  required: false
  type: 0
description: The Falcon Streaming API (formerly known as the Falcon Firehose API)
detaileddescription: Use these detailed instructions in order to retrieve the API
  key
display: CrowdStrike Falcon Streaming V2
name: integration-CrowdStrikeStreaming
script:
  commands:
  - arguments:
    - auto: PREDEFINED
      default: false
      description: The type of the IoC to upload.
      isArray: false
      name: ioc_type
      predefined:
      - sha1
      - sha256
      - md5
      - ipv4
      - ipv6
      - domain
      required: true
      secret: false
    - default: false
      description: The value of the IoC to upload.
      isArray: false
      name: ioc_value
      required: true
      secret: false
    - auto: PREDEFINED
      default: false
      description: |-
        The policy that should be enacted when the value is detected on a host.
        * detect: Send a notification when the particular indicator has been detected on a host.
        * none: Take no action when the particular indicator has been detected on a host. This is equivalent to turning the indicator off.
      isArray: false
      name: policy
      predefined:
      - detect
      - none
      required: false
      secret: false
    - default: false
      description: This represents the days the indicator should be valid for. This
        only applies to domain, ipv4, and ipv6 types.
      isArray: false
      name: expiration_days
      required: false
      secret: false
    - default: false
      description: The source where this indicator originated (limit 200 characters).
      isArray: false
      name: source
      required: false
      secret: false
    - default: false
      description: Description for the indicator (limit 200 characters).
      isArray: false
      name: description
      required: false
      secret: false
    description: Uploads a new custom IoC to crowdstrike watch list.
    execution: false
    name: crowdstrike-create-ioc
  - arguments:
    - default: false
      description: List of IoC types to retrieve, comma seperated (e.g. sha256,sha1,md5,domain,ipv4,ipv6).
      isArray: true
      name: ioc_types
      required: false
      secret: false
    - default: false
      description: List of IoC values to retrieve, comma seperated.
      isArray: false
      name: ioc_values
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      description: IoC policy to retrieve, comma seperated.
      isArray: false
      name: policy
      predefined:
      - detect
      - none
      required: false
      secret: false
    - default: false
      description: List of the IoC sources to retrieve, comma seperated.
      isArray: true
      name: sources
      required: false
      secret: false
    - default: false
      description: An RFC3339 DateTime (e.g. 2019-01-02T150:00:00Z) that represents
        the starting date range to search for IOCs by their expiration timestamp.
      isArray: false
      name: expiration_from
      required: false
      secret: false
    - default: false
      description: An RFC3339 DateTime (e.g. 2019-01-02T150:00:00Z) that represents
        the ending date range to search for IOCs by their expiration timestamp.
      isArray: false
      name: expiration_to
      required: false
      secret: false
    - default: false
      defaultValue: '50'
      description: The maximum number of records to return. The default is 50. The
        minimum is 1 and the maximum is 500.
      isArray: false
      name: limit
      required: false
      secret: false
    - default: false
      description: The ids of the IoCs to retrieve (combination of type and value
        delimited by a colon, e,g, 'domain:a-bad-domain.com'), comma seperated.
      isArray: true
      name: ids
      required: false
      secret: false
    description: Retrieves a list of IoCs.
    execution: false
    name: crowdstrike-search-iocs
    outputs:
    - contextPath: CrowdStrike.IoC.ID
      description: ID of the IoC (Type:Value).
      type: String
    - contextPath: CrowdStrike.IoC.Type
      description: Type of the IoC.
      type: String
    - contextPath: CrowdStrike.IoC.Value
      description: Value of the IoC.
      type: String
    - contextPath: CrowdStrike.IoC.Policy
      description: Policy of the IoC.
      type: String
    - contextPath: CrowdStrike.IoC.Source
      description: Source of the IoC.
      type: String
    - contextPath: CrowdStrike.IoC.ShareLevel
      description: Share level of the IoC.
      type: String
    - contextPath: CrowdStrike.IoC.Expiration
      description: Expiration timestamp of the IoC.
      type: String
    - contextPath: CrowdStrike.IoC.Description
      description: Description of the IoC.
      type: String
    - contextPath: CrowdStrike.IoC.CreatedTime
      description: Time of creation of the IoC.
      type: Date
    - contextPath: CrowdStrike.IoC.CreatedBy
      description: Identity of the creator of the IoC.
      type: String
    - contextPath: CrowdStrike.IoC.ModifiedTime
      description: Time of the last modification to the IoC.
      type: Date
    - contextPath: CrowdStrike.IoC.ModifiedBy
      description: Identity of the user who last edited the IoC.
      type: String
  isfetch: true
  runonce: false
  script: |-
    ''' IMPORTS '''

    import json
    import requests
    from distutils.util import strtobool

    # Disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    ''' GLOBALS/PARAMS '''

    USERNAME = demisto.params().get('credentials').get('identifier')
    PASSWORD = demisto.params().get('credentials').get('password')
    TOKEN = demisto.params().get('token')
    # Remove trailing slash to prevent wrong URL path to service
    SERVER = demisto.params()['url'][:-1] if (demisto.params()['url'] and demisto.params()['url'].endswith('/')) else demisto.params()['url']
    # Should we use SSL
    USE_SSL = not demisto.params().get('unsecure', False)
    # How many time before the first fetch to retrieve incidents
    FETCH_TIME = demisto.params().get('fetch_time', '3 days')
    # Headers to be sent in requests
    HEADERS = {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
    }
    # Remove proxy if not set to true in params
    if not demisto.params().get('proxy'):
        del os.environ['HTTP_PROXY']
        del os.environ['HTTPS_PROXY']
        del os.environ['http_proxy']
        del os.environ['https_proxy']

    ''' KEY DICTIONARY '''

    DETECTIONS_BASE_KEY_MAP = {
        'Detections.device.hostname': 'System',
        'Detections.device.cid': 'CustomerIDString',
        'Detections.hostinfo.domain': 'MachineDomain',
    }

    DETECTIONS_BEHAVIORS_KEY_MAP = {
        'filename': 'FileName',
        'scenario': 'ScanDetectName', #  the value doesn't match 100%, but it's close
        'md5': 'MD5String',
        'sha256': 'SHA256String',
        'ioc_type': 'IOCType',
        'ioc_value': 'IOCValue',
        'cmdline': 'CommandLine',
        'user_name': 'UserName'
    }

    SEARCH_IOC_KEY_MAP = {
        #TODO: Add ID
        'type': 'Type',
        'value': 'Value',
        'policy': 'Policy',
        'source': 'Source',
        'share_level': 'ShareLevel',
        'expiration_timestamp': 'Expiration',
        'description': 'Description',
        'created_timestamp': 'CreatedTime',
        'created_by': 'CreatedBy',
        'modified_timestamp': 'ModifiedTime',
        'modified_by': 'ModifiedBy'
    }

    ''' SPLIT KEY DICTIONARY '''

    #   Pattern: {'Path': 'Path to item', 'NewKey': 'Value of output key', 'Delim': 'Delimiter char', 'Index': Split Array Index}
    DETECTIONS_BEHAVIORS_SPLIT_KEY_MAP = [
        {
            'Path': 'parent_details.parent_process_graph_id',
            'NewKey': 'SensorID',
            'Delim': ':',
            'Index': 1
        },
        {
            'Path': 'parent_details.parent_process_graph_id',
            'NewKey': 'ParentProcessID',
            'Delim': ':',
            'Index': 2
        },
        {
            'Path': 'parent_details.parent_process_graph_id',
            'NewKey': 'ProcessStartTime',
            'Delim': ':',
            'Index': 2
        },
        {
            'Path': 'triggering_process_graph_id',
            'NewKey': 'ProcessID',
            'Delim': ':',
            'Index': 2
        },
    ]

    ''' HELPER FUNCTIONS '''

    def http_request(method, url_suffix, params=None, data=None):
        # A wrapper for requests lib to send our requests and handle requests and responses better
        demisto.info('#### url: {}'.format(SERVER + url_suffix))
        res = requests.request(
            method,
            SERVER + url_suffix,
            verify=USE_SSL,
            params=params,
            data=data,
            headers=HEADERS,
            auth=(USERNAME, PASSWORD)
        )
        demisto.info('#### STATUS CODE: {}'.format(res.status_code))
        # Handle error responses gracefully
        if res.status_code not in {200}:
            return_error('Error in API call [%d] - %s' % (res.status_code, res.reason))
        demisto.info("#### RESULT: {}".format(str(res.json())))
        return res.json()


    def create_entry_object(contents='', ec=None, hr=''):
        return {
            'Type': entryTypes['note'],
            'Contents': contents,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': hr,
            'EntryContext': ec
        }


    def behavior_to_incident(behavior, raw_response):
        demisto.info("\n\n #### IN behavior_to_incident")
        raw_labels = get_trasnformed_dict(behavior, DETECTIONS_BEHAVIORS_KEY_MAP)
        raw_labels.update(extract_transformed_dict_with_split(behavior, DETECTIONS_BEHAVIORS_SPLIT_KEY_MAP))
        for path, new_key in DETECTIONS_BASE_KEY_MAP.iteritems():
            raw_labels[new_key] = demisto.get(raw_response, path)
        labels = [{'Type': k, 'Value': v} for k, v in raw_labels.iteritems()]
        demisto.info("\n\n #### labels value: {}".format(json.dumps(labels, indent=4, sort_keys=True)))
        incident = {
            'name': 'Behavior id: ' + str(behavior.get('behavior_id')),
            'occurred': behavior.get('timestamp'),
            'rawJSON': json.dumps(behavior),
            'labels': labels
        }
        # demisto.info("\n\n #### Incident value: {}".format(json.dumps(incident, indent=4, sort_keys=True)))
        return incident


    def get_trasnformed_dict(old_dict, transformation_dict):
        """
           Returns a dictionary with the same values as old_dict, with the correlating key:value in transformation_dict
        """
        new_dict = {}
        for k in old_dict.keys():
            if k in transformation_dict:
                new_dict[transformation_dict[k]] = old_dict[k]
        return new_dict


    def extract_transformed_dict_with_split(old_dict, transformation_dict_arr):
        """
           Extracts new values out of old_dict using a json structure of:
           {'Path': 'Path to item', 'NewKey': 'Value of output key', 'Delim': 'Delimiter char', 'Index': Split Array Index}
        """
        new_dict = {}
        for trans_dict in transformation_dict_arr:
            try:
                val = demisto.get(old_dict, trans_dict['Path'])
                if 'split' in dir(val):
                    i = trans_dict['Index']
                    new_dict[trans_dict['NewKey']] = val.split(trans_dict['Delim'])[i]
            except:
                LOG('Error with: {}'.format(trans_dict))
        return new_dict


    ''' COMMAND SPECIFIC FUNCTIONS '''

    def get_detections(last_behavior_time):
        # The service endpoint to request from
        endpoint_url = '/detects/queries/detects/v1'
        # Dictionary of params for the request
        params = {
            'filter': "first_behavior:>'{0}'".format(last_behavior_time),
            'sort': 'first_behavior.asc'
        }
        # Send a request using our http_request wrapper
        response = http_request('GET', endpoint_url, params)
        # Check if response contains errors
        if response.get('errors'):
            return_error(response.get('errors'))
        return response


    def get_detections_entities(detections_ids):
        ids_json = {'ids': detections_ids}
        demisto.info("#### Data: {0}".format(json.dumps(ids_json)))
        if detections_ids:
            response = http_request('POST', '/detects/entities/summaries/GET/v1', data=json.dumps(ids_json))
            return response
        return detections_ids


    def create_ioc():
        args = demisto.args()
        payload = {}
        try:
            payload['type'] = args['ioc_type']
            payload['value'] = args['ioc_value']
            payload['policy'] = args['policy']
        except KeyError, e:
            arg = e.args[0]
            return_error("Command Error: Please provide mandatory argument: {0}".format(arg))
        payload['expiration_days'] = args.get('expiration_days')
        payload['source'] = args.get('source')
        payload['description'] = args.get('description')
        return http_request('POST', '/indicators/entities/iocs/v1', params=payload)
    # TODO: Check how an error response looks like


    def search_iocs():
        args = demisto.args()
        ids = args.get('ids')
        if not ids:
            payload = {
                'types': args.get('ioc_types', '').split(','),
                'values': args.get('ioc_values', '').split(','),
                'policies': args.get('policy', ''),
                'sources': args.get('sources', '').split(','),
                'from.expiration_timestamp': args.get('expiration_from', ''),
                'to.expiration_timestamp': args.get('expiration_to', ''),
                'limit': args.get('limit', 50)
            } #TODO: Check if sending empty arrays is ok
            ids = http_request('GET', '/indicators/queries/iocs/v1', payload).json().get('resources')
            if not ids:
                return None
        payload = {
            'ids': ids
        }
        return http_request('GET','/indicators/entities/iocs/v1', params=payload)


    def enrich_ioc_dict_with_ids(ioc_dict):
        for ioc in ioc_dict:
            ioc['ID'] = '{0}:{1}'.format(ioc.get('Type'), ioc.get('Value'))


    ''' COMMANDS FUNCTIONS '''

    def test_module():
        """
        Performs basic get request to get item samples
        """
        return http_request('GET', 'detects/queries/detects/v1')


    def fetch_incidents():
        last_run = demisto.getLastRun()
        demisto.info("#### Last run: {0}".format(last_run))
        # Get the last fetch time, if exists
        last_fetch = last_run.get('first_behavior_time')

        # Handle first time fetch, fetch incidents retroactively
        if last_fetch is None:
            last_fetch, _ = parse_date_range(FETCH_TIME, date_format='%Y-%m-%dT%H:%M:%SZ')
        last_fetch_timestamp = date_to_timestamp(last_fetch, date_format='%Y-%m-%dT%H:%M:%SZ')

        incidents = []
        detections_ids = demisto.get(get_detections(last_fetch), 'resources')
        raw_res = get_detections_entities(detections_ids)
        demisto.info('\n#### Items: {}\n'.format(raw_res))
        demisto.info('\n#### Resources: {}\n'.format(demisto.get(raw_res, 'resources')))
        if "resources" in raw_res:
            for resource in demisto.get(raw_res, "resources"):
                for behavior in demisto.get(resource, 'behaviors'):
                    incident = behavior_to_incident(behavior, resource)
                    incident_date = incident['occurred']
                    incident_date_timestamp = date_to_timestamp(incident_date, date_format='%Y-%m-%dT%H:%M:%SZ')
                    # Update last run and add incident if the incident is newer than last fetch
                    if incident_date_timestamp > last_fetch_timestamp:
                        last_fetch = incident_date
                    incidents.append(incident)

        demisto.setLastRun({'first_behavior_time': last_fetch})
        demisto.incidents(incidents)


    def create_ioc_command():
        raw_res = create_ioc()
        return create_entry_object(contents=raw_res, hr="Custom IoC was created successfully.")


    def search_iocs_command():
        raw_res = search_iocs()
        if not raw_res:
            return create_entry_object(hr='Could not find any Indicators of Compromise')
        iocs = raw_res.get('resources')
        ec = [get_trasnformed_dict(ioc, SEARCH_IOC_KEY_MAP) for ioc in iocs]
        enrich_ioc_dict_with_ids(ec)
        return create_entry_object(contents=raw_res, ec={'CrowdStrike.IoC(val.ID === obj.ID)': ec}, hr=tableToMarkdown('Indicators of Compromise', ec))

    ''' COMMANDS MANAGER / SWITCH PANEL '''

    LOG('Command being called is %s' % (demisto.command()))

    if demisto.command() == 'test-module':
        # This is the call made when pressing the integration test button.
        test_module()
        demisto.results('ok')
    elif demisto.command() == 'fetch-incidents':
        # Set and define the fetch incidents command to run after activated via integration settings.
        fetch_incidents()
    elif demisto.command() == 'crowdstrike-create-ioc':
        demisto.results(create_ioc_command())
    elif demisto.command() == 'crowdstrike-search-iocs':
        demisto.results(search_iocs_command())
  type: python
